# 탐색 알고리즘 특징 비교

| 구분1  | 구분2 | 탐색 알고리즘                                   | 특징                                                         | 시간 복잡도  |
| :----: | :---: | :---------------------------------------------- | ------------------------------------------------------------ | ------------ |
|   -    | 기본  | 순차 탐색<br />(Sequential Search)              | - 리스트를 앞에서 부터 하나씩 비교해서 찾음                  | $O(n)$       |
|   -    | 기본  | 이진 탐색<br />(Binary Search)                  | - 데이터 정렬<br />- 데이터를 중간값 기준으로 2개의 서브 리스트로 분리<br />- 데이터의 중간 위치가 찾고자 하는 값과 크기 비교<br />- 중간값 위치가 더 크면 왼쪽 서브 리스트를 사용해 위 과정 반복<br />- 중간값 위치가 더 작으면 오른쪽 서브 리스트를 사용해 위 과정 반복 | $O(log n)$   |
| 그래프 | 기본  | 너비 우선 탐색<br />(Breadth First Search, BFS) | - 한 단계씩 내려가면서, 해당 노드와 같은 레벨에 있는 노드(형제 노드)들을 먼저 순회<br />- **2개의 큐(`need_visit`, `visited`)를 이용해 구현**<br />- $V$ : 노드의 수<br />- $E$ : 간선의 수 | $O(V+E)$     |
| 그래프 | 기본  | 깊이 우선 탐색<br />(Depth First Search, DFS)   | - 한 노드의 자식을 타고 끝까지 순회<br />- 다시 돌아와서 다른 형제들의 자식을 타고 내려가면서 순회<br />- **1개의 스택(`need_visit`)과 1개의 큐(`visited`)를 이용해 구현**<br />- $V$ : 노드의 수<br />- $E$ : 간선의 수 | $O(V + E)$   |
| 그래프 | 고급  | 다익스트라 알고리즘<br />(Dijkstra Algorithm)   | - 최단 경로 알고리즘 (단일 출발 최단 경로 문제)<br />- 첫 정점을 기준으로 연결되어 있는 정점들을 추가해 가며 최단 거리 갱신<br />- BFS와 유사<br />- 우선순위 큐 활용(`MinHeap`) | $O(E log E)$ |
| 그래프 | 고급  | 크루스칼 알고리즘<br />(Kruskal Algorithm)      | - 최소 신장 트리(MST) 알고리즘<br />- 모든 정점을 독립적인 집합으로 만듬<br />- 모든 간선을 비용 기준으로 정렬<br />- 비용이 적은 간선부터 양 끝 두 정점을 비교<br />- 두 정점의 최상위 정점을 확인하고, 서로 다를 경우 두 정점을 연결 (사이클 발생 제한) |              |
| 그래프 | 고급  | Union-Find 알고리즘                             | - 크루스칼 알고리즘에서 사이클 존재유무를 판별하는 데 사용되는 알고리즘<br />- 현재까지 간선이 연결된 노드들을 집합으로 지정<br />- 간선이 연결되지 않은 노드들을 또 다른 집합으로 지정<br />- 새로운 간선을 통해 노드 연결 시,  연결되는 노드가 간선이 연결된 노드들의 집합에 포함된 노드라면 사이클이 발생한다고 판단 |              |

<br>

# (탐색 전략) 탐욕 알고리즘 (Greedy Algorithm)

## 특징

- 최적의 해에 가까운 값을 구하기 위해 사용됨
- 여러 경우 중 하나를 결정해야 할 때마다 **매 순간 최적이라고 생각되는 경우를 선택**하는 방식으로 진행되는 알고리즘

<br>

## 탐욕 알고리즘의 예

### 예시 1 : 동전 문제

- 가장 큰 동전 순서대로 정렬

```python
def min_coin_count(value, coin_list):
    total_coin_count = 0
    details = list()
    coin_list.sort(reverse=True)
    for coin in coin_list:
        coin_num = value // coin
        total_coin_count += coin_num
        value -= coin_num * coin
        details.append([coin, coin_num])
    return total_coin_count, details

coin_list = [500, 100, 50, 1]
min_coin_count(4720, coin_list)
```

```
(31, [[500, 9], [100, 2], [50, 0], [1, 20]])
```



<br>

### 예시 2 : 부분 배낭 문제 (Fractional Knapsack Problem)

- 무게대비 가치(가치(v) / 무게(w))가 큰 순서대로 정렬

```python
def get_max_value(data_list, capacity):
    data_list = sorted(data_list, key=lambda x: x[1] / x[0], reverse=True)
    total_value = 0
    details = list()
    
    for data in data_list:
        if capacity - data[0] >= 0:
            capacity -= data[0]
            total_value += data[1]
            details.append([data[0], data[1], 1])
        else:
            fraction = capacity / data[0]
            total_value += data[1] * fraction
            details.append([data[0], data[1], fraction])
            break
    return total_value, details

data_list = [(10, 10), (15, 12), (20, 10), (25, 8), (30, 5)]
get_max_value(data_list, 30)
```

```
(24.5, [[10, 10, 1], [15, 12, 1], [20, 10, 0.25]])
```



<br>

# 탐색 알고리즘 구현

## 순차 탐색 (Sequential Search) 구현

```python
def sequential(data_list, search_data):
    for index in range(len(data_list)):
        if data_list[index] == search_data:
            return index
    return -1
```

<br>

## 이진 탐색 (Binary Search) 구현

```python
def binary_search(data, search):
    print(data)
    if len(data) == 1 and search == data[0]:
        return True
    if len(data) == 1 and search != data[0]:
        return False
    if len(data) == 0:
        return False
    
    medium = len(data) // 2
    if search == data[medium]:
        return True
    else:
        if search > data[medium]:
            return binary_search(data[medium+1:], search)
        else:
            return binary_search(data[:medium], search)
```

<br>

## 그래프 표현

<img src="./img/graph.jpg" width="400px" />

```python
graph = dict()

graph['A'] = ['B', 'C']
graph['B'] = ['A', 'D']
graph['C'] = ['A', 'G', 'H', 'I']
graph['D'] = ['B', 'E', 'F']
graph['E'] = ['D']
graph['F'] = ['D']
graph['G'] = ['C']
graph['H'] = ['C']
graph['I'] = ['C', 'J']
graph['J'] = ['I']
```

<br>

## 너비 우선 탐색 (Breadth First Search, BFS) 구현

```python
def bfs(graph, start_node):
    need_visit, visited = list(), list()
    need_visit.append(start_node)
    while need_visit:
        node = need_visit.pop(0) # FIFO
        if node not in visited:
            visited.append(node)
            need_visit.extend(graph[node])
    return visited
```

<br>

## 깊이 우선 탐색 (Depth First Search, DFS) 구현

```python
def dfs(graph, start_node):
    need_visit, visited = list(), list()
    need_visit.append(start_node)
    whlie need_visit:
        node = need_visit.pop() # LIFO
        if node not in visited:
            visited.append(node)
            need_visit.extend(graph[node])
    return visited
```

<br>

## 다익스트라 알고리즘 (Dijkstra Algorithm)

```python
mygraph = {
    'A': {'B': 8, 'C': 1, 'D': 2},
    'B': {},
    'C': {'B': 5, 'D': 2},
    'D': {'E': 3, 'F': 5},
    'E': {'F': 1},
    'F': {'A': 5}
}

import heapq

def dijkstra(graph, start):
    distances = {node: float('inf') for node in graph}
    distances[start] = 0
    queue = []
    heapq.heappush(queue, [distances[start], start]) # [0, start]
    
    while queue:
        current_distance, current_node = heapq.heappop(queue) # [0, start] pop
        
        if distances[current_node] < current_distance:
            continue
        
        for adjacent, weight in graph[current_node].items():
            distance = current_distance + weight
            
            if distance < distances[adjacent]:
                distances[adjacent] = distance
                heapq.heappush(queue, [distance, adjacent])
                
    return distances
```


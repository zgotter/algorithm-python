# 기본 정렬 알고리즘 특징 비교

| 정렬 알고리즘              | 특징                                                         | 시간 복잡도                                                  |
| -------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 버블 정렬 (Bubble Sort)    | - 인접한 데이터 비교<br />- 앞의 데이터가 뒤의 데이터보다 크면 자리 바꿈 | - 평균 : $O(n^2)$<br />- 최악 : $\frac{n (n-1)}{2}​$<br />- 최선 : $O(n)​$ |
| 삽입 정렬 (Insertion Sort) | - 데이터의 두 번째 인덱스부터 시작<br />- 해당 인덱스의 값(key 값)과 앞에 있는 데이터와 대소 비교<br />- 뒤에 있는 데이터가 key 값보다 크면 해당 데이터의 인덱스를 복사<br />- 이를 key값이 더 큰 데이터를 만날때 까지 반복<br />- key값 보다 더 큰 데이터를 만난 위치 바로 뒤로 key 값을 이동 | - 평균 : $O(n^2)$<br />- 최악 : $\frac{n (n-1)}{2}$<br />- 최선 : $O(n)$ |
| 선택 정렬 (Selection Sort) | - 데이터 중 최소값을 찾음<br />- 해당 최소값을 맨 앞의 데이터와 교체<br />- 맨 앞의 위치를 뺀 나머지 데이터에 대해 위의 과정 반복 | - 평균 : $O(n^2)$<br />- 최악 : $\frac{n (n-1)}{2}$          |

<br>

# 각 정렬 알고리즘 구현

## 버블 정렬(Bubble Sort) 구현

```python
def bubblesort(data):
    for index in range(len(data) - 1):
        swap = False
        for index2 in range(len(data) - index - 1):
            if data[index2] > data[index2 + 1]:
                data[index2], data[index2 + 1] = data[index2 + 1], data[index2]
                swap = True
                
        if swap == False:
            break
    return data
```

<br>

## 삽입 정렬(Insertion Sort) 구현

```python
def insertion_sort(data):
    for index in range(len(data) - 1):
        for index2 in range(index+1, 0, -1):
            if data[index2] < data[index2 - 1]:
                data[index2], data[index2 - 1] = data[index2 - 1], data[index2]
            else:
                break
    return data
```



<br>

## 선택 정렬(Selection Sort) 구현

```python
def selection_sort(data):
    for stand in range(len(data) - 1):
        lowest = stand
        for index in range(stand+1, len(dataList)):
            if data[lowest] > data[index]:
                lowest = index
        data[stand], data[lowest] = data[lowest], data[stand]
    return data
```

